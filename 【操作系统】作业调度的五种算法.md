# 【操作系统】作业调度的五种算法

前面说了CPU具有二级调度。当作业流进入输入井的时候，首先会用作业调度来选择合适的作业进入主存区，这个合适的作业数量是根据允许并行作业的道数和作业调度的算法来决定的，此时，进入主存区的作业被操作系统创建了相应的进程，然后经过进程调度来进行占去cpu资源的操作，使得作业的执行。

![这里写图片描述](http://img.blog.csdn.net/20171121222200967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGFvRGFXYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

很好理解，对吧？

现在我们研究的对象是如何去把输入井的作业放到主存区，那么我们的重点放在作业调度的算法上来。
一般来说，作业调度的常用算法有5种。

### 1.先来先服务算法

这个算法顾名思义，先进入输入井的作业先被服务，值得注意的是，并不是先来的就一定会先被放入主存区，必须要有合适的资源才行，比如作业A进入输入井，它需要90kb的资源，但是目前只有80kb的资源，那就不能被服务。比如主存空间有100kb，A，B两个作业依次进入输入井，A需要50kb的资源，B需要60kb，首先A会被直接放去主存区，主存区目前剩余50kb，但是由于B需要60kb，因此它不会被直接放入主存区，而是等待主存区有足够的资源可以被利用。

缺点：当作业周转时间长的作业占用主存区资源时，主存区资源长时间不能被释放，后面周转时间少的作业只能处于等待状态，这无疑减少了系统的吞吐量。

### 2.计算时间短的作业优先的算法

这个作业调度算法只是把计算时间较短的作业优先服务，实质上，它还是采用了先来先服务的算法，设每个任务的周转时间为Ti。所有作业的平均周转时间为

```
T = (T1 + T2 + T3 + T4 + ... + Tn) * (n/1)
```

由于T1 <= T2 <= T3 <= T4 <= … Tn ，T取得最小值，因此每个作业的周转时间取得最小值，T取得最小值。

缺点：考虑一下这样一个情况，如果首先进入输入井的是一个耗时的作业， 但接下来进来的都是短时作业，那么短时作业肯定会根据计算时间短的作业优先算法先执行短时作业，而耗时作业没有可以被执行的机会，因此，这可能会令用户体验不佳

### 3.响应比高者优先算法

这个算法综合了钱两个算法，一个是忽略了计算时间，一个是忽略了等待时间，而响应比高者优先算法恰好是一个中庸的算法，它利用了响应比来判断是否应该服务。

```
响应比 ： 等待时间/计算时间
```

等待时间很长的作业会使响应比很大，计算时间很少的作业也会使响应比增加，这样用响应比就可以兼顾两头，可以说是一个中庸的算法。用这种算法会使所有作业流进入输入井完毕后开始调度，计算出所有作业的响应比再开始比较，因此这种算法会带来一个明显的效率问题。当作业数量多的时候，计算所有作业的响应比本身就是一个很耗时的操作了。

### 4.优先级调度算法

顾名思义了。这种算法使用优先级来决定谁先被服务。
设定优先级会有两种方法，第一是用户自己设定，第二种是系统设定。系统设定会根据作业的类型，作业的等待时间，计算时间，作业的缓急程度等等各方面的因素来判断是否应该被服务，有些系统还能在输入井根据各方面因素来动态改变优先级。

### 5.均衡调度算法

这种算法的主要依据是资源，根据使用不同的资源进行分类，使得占用不同资源的作业能够同时执行，从而提高效率，和系统的吞吐量。

